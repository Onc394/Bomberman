<!DOCTYPE html>
<html lang="es">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Bomberman Auto Farm PRO - Ronin</title>
  <link href="https://fonts.googleapis.com/css2?family=Press+Start+2P&family=Roboto:wght@400;700&display=swap" rel="stylesheet">
  <script src="https://cdn.ethers.io/lib/ethers-5.2.umd.min.js"></script>
  <style>
    :root {
      --bg-dark: #1a1a2e;
      --bg-light: #16213e;
      --accent: #ff9f43;
      --gold: #ffd700;
      --text: #e6e6e6;
      --common: #bdc3c7;
      --uncommon: #3498db;
      --rare: #2ecc71;
      --epic: #9b59b6;
      --legendary: #f1c40f;
      --tab-active: #2a2a4a;
      --tab-inactive: #1e1e3a;
    }

    * {
      box-sizing: border-box;
      margin: 0;
      padding: 0;
    }

    body {
      display: flex;
      flex-direction: column;
      align-items: center;
      min-height: 100vh;
      font-family: 'Roboto', sans-serif;
      background: linear-gradient(135deg, var(--bg-dark), var(--bg-light));
      color: var(--text);
      padding: 20px;
    }

    h1 {
      font-family: 'Press Start 2P', cursive;
      color: var(--accent);
      text-shadow: 3px 3px 0px rgba(0, 0, 0, 0.5);
      margin: 20px 0;
      font-size: 2rem;
      text-align: center;
    }

    #stats {
      display: flex;
      gap: 20px;
      margin-bottom: 15px;
      flex-wrap: wrap;
      justify-content: center;
    }

    .stat-box {
      background: rgba(0, 0, 0, 0.7);
      padding: 10px 20px;
      border-radius: 10px;
      border: 2px solid var(--accent);
      min-width: 150px;
      text-align: center;
    }

    #gold {
      color: var(--gold);
      font-weight: bold;
      font-size: 1.2rem;
    }

    #level {
      color: #4cc9f0;
      font-weight: bold;
      font-size: 1.2rem;
    }

    #xp {
      color: #f72585;
      font-weight: bold;
      font-size: 1.2rem;
    }

    #wallet {
      color: #80ffdb;
      font-weight: bold;
      font-size: 0.9rem;
      word-break: break-all;
    }

    #game-container {
      display: flex;
      flex-wrap: wrap;
      justify-content: center;
      gap: 20px;
      width: 100%;
      max-width: 1400px;
    }

    #game-canvas {
      background: #222;
      border: 4px solid var(--accent);
      border-radius: 10px;
      box-shadow: 0 0 20px rgba(0, 0, 0, 0.8);
      order: 2; /* Mapa en el medio */
    }

    /* Panel izquierdo - Personajes */
    .left-panel {
      display: flex;
      flex-direction: column;
      min-width: 250px;
      width: 250px;
      height: 450px;
      background: rgba(30, 30, 60, 0.8);
      border-radius: 15px;
      box-shadow: 0 5px 15px rgba(0, 0, 0, 0.5);
      border: 2px solid rgba(255, 255, 255, 0.1);
      overflow: hidden;
      order: 1; /* Panel izquierdo primero */
    }

    /* Panel derecho - Tienda/Ronin */
    .right-panel {
      display: flex;
      flex-direction: column;
      min-width: 250px;
      width: 250px;
      height: 450px;
      background: rgba(30, 30, 60, 0.8);
      border-radius: 15px;
      box-shadow: 0 5px 15px rgba(0, 0, 0, 0.5);
      border: 2px solid rgba(255, 255, 255, 0.1);
      overflow: hidden;
      order: 3; /* Panel derecho √∫ltimo */
    }

    .tab-buttons {
      display: flex;
      background: var(--tab-inactive);
      border-bottom: 2px solid var(--accent);
    }

    .tab-button {
      flex: 1;
      padding: 12px 0;
      background: transparent;
      border: none;
      color: var(--text);
      font-family: 'Press Start 2P', cursive;
      font-size: 0.7rem;
      cursor: pointer;
      transition: all 0.3s;
      position: relative;
      text-transform: uppercase;
      letter-spacing: 1px;
    }

    .tab-button:hover {
      background: rgba(255, 255, 255, 0.1);
    }

    .tab-button.active {
      background: var(--tab-active);
      color: var(--accent);
    }

    .tab-button.active::after {
      content: '';
      position: absolute;
      bottom: -2px;
      left: 0;
      width: 100%;
      height: 2px;
      background: var(--accent);
    }

    .tab-content {
      display: none;
      padding: 15px;
      height: calc(100% - 44px);
      overflow-y: auto;
      animation: fadeIn 0.3s ease-out;
    }

    .tab-content.active {
      display: block;
    }

    @keyframes fadeIn {
      from { opacity: 0; transform: translateY(10px); }
      to { opacity: 1; transform: translateY(0); }
    }

    .panel-title {
      font-family: 'Press Start 2P', cursive;
      color: var(--accent);
      font-size: 0.9rem;
      margin-bottom: 15px;
      text-align: center;
    }

    .shop-rarity-list {
      margin-bottom: 15px;
    }

    .shop-rarity-item {
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: 8px 10px;
      margin-bottom: 8px;
      background: rgba(0, 0, 0, 0.3);
      border-radius: 5px;
      border-left: 3px solid;
    }

    .shop-rarity-item.common { border-color: var(--common); }
    .shop-rarity-item.uncommon { border-color: var(--uncommon); }
    .shop-rarity-item.rare { border-color: var(--rare); }
    .shop-rarity-item.epic { border-color: var(--epic); }
    .shop-rarity-item.legendary { border-color: var(--legendary); }

    .character-card {
      background: rgba(50, 50, 80, 0.7);
      border-radius: 8px;
      padding: 10px;
      margin: 10px 0;
      border-left: 4px solid;
      transition: transform 0.2s, box-shadow 0.2s;
    }

    .character-card:hover {
      transform: translateY(-3px);
      box-shadow: 0 5px 10px rgba(0, 0, 0, 0.3);
    }

    .character-card.common { border-color: var(--common); }
    .character-card.uncommon { border-color: var(--uncommon); }
    .character-card.rare { border-color: var(--rare); }
    .character-card.epic { border-color: var(--epic); }
    .character-card.legendary { border-color: var(--legendary); }

    .character-name {
      font-weight: bold;
      margin-bottom: 5px;
      display: flex;
      justify-content: space-between;
    }

    .character-level {
      background: rgba(0, 0, 0, 0.3);
      padding: 2px 6px;
      border-radius: 10px;
      font-size: 0.8rem;
    }

    .bar-container {
      height: 8px;
      background: rgba(0, 0, 0, 0.3);
      border-radius: 4px;
      margin: 5px 0;
      overflow: hidden;
    }

    .bar {
      height: 100%;
      border-radius: 4px;
      transition: width 0.3s;
    }

    .energy-bar { background: linear-gradient(90deg, #00b09b, #96c93d); }
    .health-bar { background: linear-gradient(90deg, #ff416c, #ff4b2b); }
    .xp-bar { background: linear-gradient(90deg, #f72585, #b5179e); }

    button {
      background: linear-gradient(135deg, var(--accent), #ff7b25);
      color: white;
      border: none;
      padding: 8px 15px;
      border-radius: 50px;
      font-weight: bold;
      cursor: pointer;
      transition: all 0.3s;
      margin-top: 5px;
      width: 100%;
      font-family: 'Roboto', sans-serif;
      text-transform: uppercase;
      letter-spacing: 1px;
      box-shadow: 0 4px 0 rgba(0, 0, 0, 0.2);
      font-size: 0.8rem;
    }

    button:hover {
      transform: translateY(-2px);
      box-shadow: 0 6px 0 rgba(0, 0, 0, 0.2);
    }

    button:active {
      transform: translateY(1px);
      box-shadow: 0 2px 0 rgba(0, 0, 0, 0.2);
    }

    button:disabled {
      background: #666;
      cursor: not-allowed;
      transform: none;
      box-shadow: none;
    }

    .recharge-button {
      background: linear-gradient(135deg, #4cc9f0, #4895ef) !important;
    }

    /* Nuevos estilos para la tienda Ronin */
    #roninShop {
      background: rgba(0, 0, 0, 0.7);
      padding: 15px;
      border-radius: 10px;
      margin-top: 20px;
      border: 2px solid #4cc9f0;
    }
    .pack {
      background: rgba(50, 50, 80, 0.7);
      padding: 10px;
      margin: 10px 0;
      border-radius: 8px;
      cursor: pointer;
      transition: all 0.3s;
    }
    .pack:hover {
      transform: translateY(-3px);
      background: rgba(70, 70, 100, 0.7);
    }
    #withdrawSection {
      margin-top: 20px;
      background: rgba(0, 0, 0, 0.5);
      padding: 15px;
      border-radius: 10px;
    }
    #withdrawAmount {
      padding: 8px;
      width: 100%;
      margin-bottom: 10px;
      background: #333;
      color: white;
      border: 1px solid #4cc9f0;
    }
    #withdrawStatus {
      margin-top: 10px;
      font-size: 0.8rem;
      min-height: 20px;
    }

    .revive-button {
      background: linear-gradient(135deg, #f72585, #b5179e) !important;
    }

    .dead-character {
      opacity: 0.6;
      position: relative;
    }

    .dead-character::after {
      content: "üíÄ";
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      font-size: 2rem;
      z-index: 10;
    }

    /* Estilos para la Slot Machine (nuevo dise√±o) */
    #slot-machine-container {
      width: 100%;
      max-width: 1200px;
      margin-top: 20px;
      background: rgba(0, 0, 0, 0.7);
      border-radius: 10px;
      padding: 20px;
      border: 4px solid var(--accent);
      box-shadow: 0 0 20px rgba(255, 215, 0, 0.3);
    }

    #slot-machine {
      display: flex;
      flex-direction: column;
      align-items: center;
    }

    #slot-display {
      display: flex;
      justify-content: center;
      gap: 15px;
      margin: 20px 0;
      perspective: 1000px;
      height: 100px;
      align-items: center;
    }

    .slot-reel {
      width: 80px;
      height: 80px;
      background: #333;
      border-radius: 10px;
      position: relative;
      border: 3px solid var(--accent);
      box-shadow: 0 0 15px rgba(255, 215, 0, 0.5);
      overflow: hidden;
    }

    .slot-symbol {
      position: absolute;
      width: 100%;
      height: 100%;
      display: flex;
      justify-content: center;
      align-items: center;
      font-size: 3rem;
      backface-visibility: hidden;
      transform-style: preserve-3d;
      transition: transform 0.5s ease-out;
    }

    .slot-reel.spinning .slot-symbol {
      animation: spin 0.1s infinite linear;
    }

    @keyframes spin {
      0% { transform: translateY(0) rotateX(0); }
      100% { transform: translateY(-100%) rotateX(360deg); }
    }

    /* Colores para los s√≠mbolos */
    .slot-symbol[data-type="bomb"] { color: #ff5555; }
    .slot-symbol[data-type="dynamite"] { color: #ff9900; }
    .slot-symbol[data-type="diamond"] { color: #55ffff; }
    .slot-symbol[data-type="amulet"] { color: #aa55ff; }
    .slot-symbol[data-type="crown"] { color: #ffd700; }
    .slot-symbol[data-type="jackpot"] { color: #ffff55; text-shadow: 0 0 10px gold; }

    #jackpot-display {
      margin: 10px 0;
      font-weight: bold;
      color: var(--gold);
      font-size: 1.5rem;
      text-shadow: 0 0 10px rgba(255, 215, 0, 0.7);
    }

    #slot-result {
      min-height: 30px;
      margin: 15px 0;
      font-weight: bold;
      font-size: 1.2rem;
      text-align: center;
    }

    .spin-button {
      background: linear-gradient(135deg, #f72585, #b5179e);
      font-size: 1.2rem;
      padding: 12px 30px;
      border-radius: 50px;
      box-shadow: 0 0 15px rgba(247, 37, 133, 0.5);
      margin-top: 10px;
      transition: all 0.3s;
    }

    .spin-button:hover {
      transform: translateY(-3px);
      box-shadow: 0 0 20px rgba(247, 37, 133, 0.8);
    }

    .prizes-container {
      display: flex;
      justify-content: space-around;
      width: 100%;
      margin-top: 20px;
      flex-wrap: wrap;
    }

    .prize-item {
      display: flex;
      flex-direction: column;
      align-items: center;
      margin: 10px;
      padding: 10px;
      background: rgba(50, 50, 80, 0.7);
      border-radius: 10px;
      min-width: 100px;
    }

    .prize-icon {
      font-size: 2rem;
      margin-bottom: 5px;
    }

    .prize-amount {
      color: var(--gold);
      font-weight: bold;
    }

    @media (max-width: 1200px) {
      #game-container {
        flex-direction: column;
        align-items: center;
      }

      .left-panel, .right-panel {
        width: 100%;
        max-width: 500px;
      }

      #game-canvas {
        order: 1;
      }

      .left-panel {
        order: 2;
      }

      .right-panel {
        order: 3;
      }

      #slot-machine-container {
        order: 4;
      }
    }

    @media (max-width: 768px) {
      .tab-button {
        font-size: 0.6rem;
        padding: 10px 0;
      }
      
      button {
        font-size: 0.7rem;
        padding: 6px 10px;
      }

      #slot-display {
        font-size: 2rem;
      }

      .slot-reel {
        width: 60px;
        height: 60px;
      }
    }
  </style>
</head>
<body>
  <h1>BOMBERMAN AUTO FARM PRO</h1>
  
  <div id="stats">
    <div class="stat-box">
      <div>ORO</div>
      <div id="gold">0.00</div>
    </div>
    <div class="stat-box">
      <div>NIVEL</div>
      <div id="level">1</div>
    </div>
    <div class="stat-box">
      <div>EXPERIENCIA</div>
      <div id="xp">0/100</div>
    </div>
    <div class="stat-box">
      <div>WALLET</div>
      <div id="wallet">No conectada</div>
    </div>
  </div>
  
  <div id="game-container">
    <!-- Panel izquierdo - Personajes -->
    <div class="left-panel">
      <div class="tab-buttons">
        <button class="tab-button active" data-tab="active-characters">Activos</button>
        <button class="tab-button" data-tab="inactive-characters">Inactivos</button>
      </div>
      
      <div class="tab-content active" id="active-characters-tab">
        <div class="panel-title">PERSONAJES ACTIVOS</div>
        <div id="active-characters"></div>
      </div>
      
      <div class="tab-content" id="inactive-characters-tab">
        <div class="panel-title">PERSONAJES INACTIVOS</div>
        <div id="inactive-characters"></div>
      </div>
    </div>
    
    <!-- Mapa del juego -->
    <canvas id="game-canvas" width="630" height="450"></canvas>
    
    <!-- Panel derecho - Tienda/Ronin -->
    <div class="right-panel">
      <div class="tab-buttons">
        <button class="tab-button active" data-tab="shop">Tienda</button>
        <button class="tab-button" data-tab="ronin">Ronin</button>
      </div>
      
      <div class="tab-content active" id="shop-tab">
        <div class="panel-title">TIENDA</div>
        <div class="shop-rarity-list">
          <div class="shop-rarity-item common">
            <span>COM√öN</span>
          </div>
          <div class="shop-rarity-item uncommon">
            <span>POCO COM√öN</span>
          </div>
          <div class="shop-rarity-item rare">
            <span>RARO</span>
          </div>
          <div class="shop-rarity-item epic">
            <span>√âPICO</span>
          </div>
          <div class="shop-rarity-item legendary">
            <span>LEGENDARIO</span>
          </div>
        </div>
        <button id="buy-character">COMPRAR PERSONAJE (1000 ORO)</button>
      </div>

      <!-- Pesta√±a Ronin -->
      <div class="tab-content" id="ronin-tab">
        <div class="panel-title">RONIN WALLET</div>
        <button id="connectRonin">Conectar Wallet</button>
        
        <div id="roninShop">
          <h4>Comprar Oro con RON</h4>
          <div class="pack" data-pack="small">
            <p>1000 Oro</p>
            <p>1 RON</p>
          </div>
          <div class="pack" data-pack="medium">
            <p>5500 Oro</p>
            <p>5 RON (+10%)</p>
          </div>
          <div class="pack" data-pack="large">
            <p>12000 Oro</p>
            <p>10 RON (+20%)</p>
          </div>
        </div>
        
        <div id="withdrawSection">
          <h4>Retirar Oro a RON</h4>
          <input type="number" id="withdrawAmount" placeholder="Oro a retirar">
          <button onclick="requestWithdraw()">Solicitar Retiro</button>
          <p>Tasa: 1000 oro = 1 RON</p>
          <p id="withdrawStatus"></p>
        </div>
      </div>
    </div>
  </div>

  <!-- Slot Machine en la parte inferior -->
  <div id="slot-machine-container">
    <div id="slot-machine">
      <div class="panel-title">SLOT MACHINE</div>
      <div id="jackpot-display">JACKPOT: 0 ORO</div>
      <div id="slot-display">
        <div class="slot-reel">
          <div class="slot-symbol">üí£</div>
        </div>
        <div class="slot-reel">
          <div class="slot-symbol">üß®</div>
        </div>
        <div class="slot-reel">
          <div class="slot-symbol">üíé</div>
        </div>
      </div>
      <div id="slot-result"></div>
      <button class="spin-button" id="spin-button">GIRAR (100 ORO)</button>
      
      <div class="prizes-container">
        <div class="prize-item">
          <div class="prize-icon">üí£</div>
          <div class="prize-amount">50 ORO</div>
          <div>3 Bombas</div>
        </div>
        <div class="prize-item">
          <div class="prize-icon">üß®</div>
          <div class="prize-amount">100 ORO</div>
          <div>3 Dinamitas</div>
        </div>
        <div class="prize-item">
          <div class="prize-icon">üíé</div>
          <div class="prize-amount">150 ORO</div>
          <div>3 Diamantes</div>
        </div>
        <div class="prize-item">
          <div class="prize-icon">üßø</div>
          <div class="prize-amount">200 ORO</div>
          <div>3 Amuletos</div>
        </div>
        <div class="prize-item">
          <div class="prize-icon">üëë</div>
          <div class="prize-amount">500 ORO</div>
          <div>3 Coronas</div>
        </div>
        <div class="prize-item">
          <div class="prize-icon">üí∞</div>
          <div class="prize-amount">JACKPOT</div>
          <div>3 S√≠mbolos de Oro</div>
        </div>
      </div>
      <p style="margin-top: 15px; text-align: center;">¬°Cada giro contribuye 10 oro al jackpot!</p>
    </div>
  </div>

  <!-- Sonidos -->
  <audio id="sound-explosion" src="https://assets.mixkit.co/sfx/preview/mixkit-arcade-game-explosion-2759.mp3" preload="auto"></audio>
  <audio id="sound-buy" src="https://assets.mixkit.co/sfx/preview/mixkit-unlock-game-notification-253.mp3" preload="auto"></audio>
  <audio id="sound-gold" src="https://assets.mixkit.co/sfx/preview/mixkit-coins-handling-1939.mp3" preload="auto"></audio>
  <audio id="sound-levelup" src="https://assets.mixkit.co/sfx/preview/mixkit-achievement-bell-600.mp3" preload="auto"></audio>
  <audio id="sound-powerup" src="https://assets.mixkit.co/sfx/preview/mixkit-bonus-earned-2065.mp3" preload="auto"></audio>
  <audio id="sound-recharge" src="https://assets.mixkit.co/sfx/preview/mixkit-positive-interface-beep-221.mp3" preload="auto"></audio>
  <audio id="sound-revive" src="https://assets.mixkit.co/sfx/preview/mixkit-magic-sparkle-902.mp3" preload="auto"></audio>
  <audio id="sound-slot" src="https://assets.mixkit.co/sfx/preview/mixkit-slot-machine-spin-1930.mp3" preload="auto"></audio>
  <audio id="sound-win" src="https://assets.mixkit.co/sfx/preview/mixkit-winning-chimes-2015.mp3" preload="auto"></audio>

  <script>
    // ================ CONFIGURACI√ìN INICIAL ================
    const canvas = document.getElementById("game-canvas");
    const ctx = canvas.getContext("2d");
    const TILE_SIZE = 30;
    const MAP_WIDTH = 21;
    const MAP_HEIGHT = 15;
    
    // Configuraci√≥n Ronin
    const RONIN_SHOP = {
      small: { ron: 1, gold: 1000 },
      medium: { ron: 5, gold: 5500 },
      large: { ron: 10, gold: 12000 }
    };
    const HOUSE_WALLET = "0xTuBilleteraRonin"; // REEMPLAZA CON TU WALLET

    // Configuraci√≥n Slot Machine (actualizada con s√≠mbolos de personajes)
    const SLOT_CONFIG = {
      cost: 100, // Oro por giro
      jackpotContribution: 10, // Oro que va al jackpot por giro
      items: [
        { 
          icon: "üí£", 
          type: "bomb",
          name: "Bomba",
          prob: 0.3,
          reward: { gold: 50 },
          color: "#ff5555"
        },
        { 
          icon: "üß®", 
          type: "dynamite",
          name: "Dinamita",
          prob: 0.25,
          reward: { gold: 100 },
          color: "#ff9900"
        },
        { 
          icon: "üíé", 
          type: "diamond",
          name: "Diamante",
          prob: 0.2,
          reward: { gold: 150 },
          color: "#55ffff"
        },
        { 
          icon: "üßø", 
          type: "amulet",
          name: "Amuleto",
          prob: 0.15,
          reward: { gold: 200 },
          color: "#aa55ff"
        },
        { 
          icon: "üëë", 
          type: "crown",
          name: "Corona",
          prob: 0.05,
          reward: { gold: 500 },
          color: "#ffd700"
        },
        { 
          icon: "üí∞", 
          type: "jackpot",
          name: "Jackpot",
          prob: 0.05,
          reward: { jackpot: true },
          color: "#ffff55"
        }
      ],
      combinations: [
        { types: ["bomb", "bomb", "bomb"], reward: 50 },
        { types: ["dynamite", "dynamite", "dynamite"], reward: 100 },
        { types: ["diamond", "diamond", "diamond"], reward: 150 },
        { types: ["amulet", "amulet", "amulet"], reward: 200 },
        { types: ["crown", "crown", "crown"], reward: 500 },
        { types: ["jackpot", "jackpot", "jackpot"], reward: "jackpot" }
      ]
    };

    // Distribuci√≥n de oro en cofres
    const GOLD_DROPS = [
      { amount: 0.5, chance: 1.0 } // Todos los cofres dan 0.5 oro base
    ];

    // Costos de recarga por rareza
    const RECHARGE_COSTS = {
      common: 10,
      uncommon: 15,
      rare: 20,
      epic: 25,
      legendary: 30
    };

    // Tipos de rareza (actualizado para ROI diferenciado)
    const RARITIES = [
      { 
        name: "COM√öN", 
        class: "common",
        color: "#bdc3c7", 
        chance: 0.01,
        baseEnergy: 100,
        baseDamage: 0.1,
        baseSpeed: 0.03,
        roiDays: 45,
        bombCost: 1,
        symbol: "üí£"
      },
      { 
        name: "POCO COM√öN", 
        class: "uncommon",
        color: "#3498db", 
        chance: 0.25,
        baseEnergy: 150,
        baseDamage: 0.15,
        baseSpeed: 0.05,
        roiDays: 35,
        bombCost: 1,
        symbol: "üí£"
      },
      { 
        name: "RARO", 
        class: "rare",
        color: "#2ecc71", 
        chance: 0.15,
        baseEnergy: 200,
        baseDamage: 0.25,
        baseSpeed: 0.08,
        roiDays: 25,
        bombCost: 1,
        symbol: "üí£"
      },
      { 
        name: "√âPICO", 
        class: "epic",
        color: "#9b59b6", 
        chance: 0.04,
        baseEnergy: 300,
        baseDamage: 0.4,
        baseSpeed: 0.12,
        roiDays: 20,
        bombCost: 1,
        symbol: "üí£"
      },
      { 
        name: "LEGENDARIO", 
        class: "legendary",
        color: "#f1c40f", 
        chance: 0.55,
        baseEnergy: 500,
        baseDamage: 0.7,
        baseSpeed: 0.2,
        roiDays: 15,
        bombCost: 1,
        symbol: "üí£"
      }
    ];

    // Tipos de power-ups
    const POWER_UPS = [
      {
        type: "speed",
        color: "#4cc9f0",
        effect: (char) => { char.speed *= 1.5; setTimeout(() => char.speed /= 1.5, 10000); },
        chance: 0.2
      },
      {
        type: "damage",
        color: "#f72585",
        effect: (char) => { char.damage *= 2; setTimeout(() => char.damage /= 2, 10000); },
        chance: 0.2
      },
      {
        type: "energy",
        color: "#80ffdb",
        effect: (char) => { char.energy = char.maxEnergy; },
        chance: 0.3
      },
      {
        type: "gold",
        color: "#ffd700",
        effect: (char) => { gameState.gold += 5; updateGameDisplay(); },
        chance: 0.3
      }
    ];

    // Estado del juego (actualizado)
    const gameState = {
      gold: 9000, // Oro inicial
      level: 1,
      xp: 0,
      xpToNextLevel: 100,
      characters: [],
      activeCharacters: [],
      boxes: [],
      breakableWalls: [],
      fixedWalls: [],
      bombs: [],
      goldNotifications: [],
      levelUpNotifications: [],
      powerUps: [],
      walletAddress: null,
      ronBalance: 0,
      mapSeed: null, // Semilla para mantener el mismo mapa
      mapState: null, // Estado actual del mapa
      // Estado de la Slot Machine
      slotMachine: {
        jackpot: 0,
        spinning: false,
        reels: ["bomb", "bomb", "bomb"] // Estado actual de los rodillos
      }
    };

    // Elementos del DOM
    const goldDisplay = document.getElementById("gold");
    const levelDisplay = document.getElementById("level");
    const xpDisplay = document.getElementById("xp");
    const walletDisplay = document.getElementById("wallet");
    const buyButton = document.getElementById("buy-character");
    const connectRoninBtn = document.getElementById("connectRonin");
    const spinButton = document.getElementById("spin-button");
    const slotResultDisplay = document.getElementById("slot-result");
    const jackpotDisplay = document.getElementById("jackpot-display");
    const slotReels = document.querySelectorAll(".slot-reel");
    const activeCharactersDiv = document.getElementById("active-characters");
    const inactiveCharactersDiv = document.getElementById("inactive-characters");
    
    // Sonidos
    const soundExplosion = document.getElementById("sound-explosion");
    const soundBuy = document.getElementById("sound-buy");
    const soundGold = document.getElementById("sound-gold");
    const soundLevelUp = document.getElementById("sound-levelup");
    const soundPowerUp = document.getElementById("sound-powerup");
    const soundRecharge = document.getElementById("sound-recharge");
    const soundRevive = document.getElementById("sound-revive");
    const soundSlot = document.getElementById("sound-slot");
    const soundWin = document.getElementById("sound-win");

    // ================ FUNCIONES SLOT MACHINE ================
    function spinSlot() {
      if (gameState.slotMachine.spinning) return;
      if (gameState.gold < SLOT_CONFIG.cost) {
        slotResultDisplay.textContent = "¬°No tienes suficiente oro!";
        slotResultDisplay.style.color = "#f72585";
        return;
      }

      // Descontar oro y contribuir al jackpot
      gameState.gold -= SLOT_CONFIG.cost;
      gameState.slotMachine.jackpot += SLOT_CONFIG.jackpotContribution;
      updateGameDisplay();
      updateJackpotDisplay();

      // Iniciar animaci√≥n
      gameState.slotMachine.spinning = true;
      spinButton.disabled = true;
      soundSlot.play();

      // A√±adir clase de spinning a los rodillos
      const reels = document.querySelectorAll('.slot-reel');
      reels.forEach(reel => reel.classList.add("spinning"));

      // Resultados finales para cada rodillo
      const finalResults = [];
      const spinDurations = [1500, 2000, 2500]; // 1.5s, 2s, 2.5s

      // Girar cada rodillo con duraci√≥n diferente
      reels.forEach((reel, index) => {
        // Animaci√≥n temporal con s√≠mbolos aleatorios
        const symbols = reel.querySelector('.slot-symbol');
        const spinInterval = setInterval(() => {
          const randomItem = weightedRandom(SLOT_CONFIG.items);
          symbols.textContent = randomItem.icon;
          symbols.setAttribute('data-type', randomItem.type);
          symbols.style.color = randomItem.color;
        }, 100);

        // Detener despu√©s de la duraci√≥n asignada
        setTimeout(() => {
          clearInterval(spinInterval);
          
          // Determinar resultado final con aleatoriedad
          let finalItem;
          const rand = Math.random();
          
          // 5% de chance de jackpot
          if (rand < 0.05) {
            finalItem = SLOT_CONFIG.items.find(item => item.type === "jackpot");
          } 
          // 15% de chance de premio mayor
          else if (rand < 0.20) {
            const highRewards = SLOT_CONFIG.items.filter(item => item.reward.gold >= 200);
            finalItem = highRewards[Math.floor(Math.random() * highRewards.length)];
          } 
          // Resto probabilidades normales
          else {
            finalItem = weightedRandom(SLOT_CONFIG.items);
          }
          
          finalResults[index] = finalItem;
          symbols.textContent = finalItem.icon;
          symbols.setAttribute('data-type', finalItem.type);
          symbols.style.color = finalItem.color;
          gameState.slotMachine.reels[index] = finalItem.type;

          // Quitar clase de spinning cuando todos terminen
          if (index === 2) {
            setTimeout(() => {
              reels.forEach(r => r.classList.remove("spinning"));
              gameState.slotMachine.spinning = false;
              spinButton.disabled = false;
              evaluateSpinResult();
            }, 500);
          }
        }, spinDurations[index]);
      });
    }

    function weightedRandom(items) {
      let total = items.reduce((sum, item) => sum + item.prob, 0);
      let random = Math.random() * total;
      
      for (const item of items) {
        if (random < item.prob) return item;
        random -= item.prob;
      }
      
      return items[0];
    }

    function evaluateSpinResult() {
      const reelTypes = gameState.slotMachine.reels;
      let winAmount = 0;
      let winType = "";
      let wonJackpot = false;

      // Verificar combinaciones ganadoras
      for (const combo of SLOT_CONFIG.combinations) {
        if (reelTypes.every((type, i) => type === combo.types[i])) {
          if (combo.reward === "jackpot") {
            winAmount = gameState.slotMachine.jackpot;
            gameState.slotMachine.jackpot = 0;
            wonJackpot = true;
            winType = "JACKPOT";
          } else {
            winAmount = combo.reward;
            winType = SLOT_CONFIG.items.find(item => item.type === combo.types[0]).name;
          }
          break;
        }
      }

      // Mostrar resultado
      if (winAmount > 0) {
        if (wonJackpot) {
          slotResultDisplay.textContent = `¬°JACKPOT! GANASTE ${winAmount} ORO`;
          slotResultDisplay.style.color = "#ffd700";
          soundWin.play();
          
          gameState.goldNotifications.push({
            x: Math.floor(MAP_WIDTH / 2) * TILE_SIZE,
            y: Math.floor(MAP_HEIGHT / 2) * TILE_SIZE,
            text: `¬°JACKPOT! +${winAmount}`,
            time: Date.now(),
            color: "#ffd700"
          });
        } else {
          slotResultDisplay.textContent = `¬°${winType}! GANASTE ${winAmount} ORO`;
          slotResultDisplay.style.color = "#2ecc71";
          soundGold.play();
        }
        gameState.gold += winAmount;
      } else {
        slotResultDisplay.textContent = "¬°Sigue intentando!";
        slotResultDisplay.style.color = "#f72585";
      }

      updateGameDisplay();
      updateJackpotDisplay();
      saveGame();
    }

    function updateJackpotDisplay() {
      jackpotDisplay.textContent = `JACKPOT: ${gameState.slotMachine.jackpot} ORO`;
    }

    // ================ FUNCIONES RONIN ACTUALIZADAS ================
    
    // Verifica si Ronin Wallet est√° instalado
    function isRoninInstalled() {
      return typeof window.ronin !== 'undefined' || 
             typeof window.ethereum !== 'undefined' && 
             window.ethereum.isRonin;
    }

    // Conecta con Ronin Wallet
    async function connectRonin() {
      try {
        // Verificar si la extensi√≥n est√° instalada
        if (!isRoninInstalled()) {
          const shouldInstall = confirm('Ronin Wallet no est√° instalada. ¬øDeseas instalarla ahora?');
          if (shouldInstall) {
            window.open('https://wallet.roninchain.com', '_blank');
          }
          return;
        }

        // Usar el proveedor Ronin o Ethereum
        const provider = window.ronin?.provider || window.ethereum;
        
        // Solicitar conexi√≥n de cuentas
        const accounts = await provider.request({
          method: 'eth_requestAccounts'
        });

        if (accounts.length === 0) {
          throw new Error('No se encontraron cuentas conectadas');
        }

        // Actualizar estado del juego
        gameState.walletAddress = accounts[0];
        walletDisplay.textContent = `${accounts[0].slice(0, 6)}...${accounts[0].slice(-4)}`;
        
        // Escuchar cambios de cuenta
        provider.on('accountsChanged', (newAccounts) => {
          if (newAccounts.length === 0) {
            // Wallet desconectada
            gameState.walletAddress = null;
            walletDisplay.textContent = "No conectada";
          } else {
            // Cuenta cambiada
            gameState.walletAddress = newAccounts[0];
            walletDisplay.textContent = `${newAccounts[0].slice(0, 6)}...${newAccounts[0].slice(-4)}`;
          }
        });

        // Verificar balance
        await checkRoninBalance();
        
        alert(`¬°Wallet conectada correctamente! (${walletDisplay.textContent})`);
      } catch (error) {
        console.error("Error al conectar:", error);
        alert("Error al conectar: " + (error.message || error));
      }
    }

    // Verificar balance RON
    async function checkRoninBalance() {
      if (!gameState.walletAddress) return;
      
      try {
        const provider = new ethers.providers.Web3Provider(
          window.ronin?.provider || window.ethereum
        );
        const balance = await provider.getBalance(gameState.walletAddress);
        gameState.ronBalance = parseFloat(ethers.utils.formatEther(balance));
      } catch (error) {
        console.error("Error al verificar balance:", error);
      }
    }

    // Comprar oro con RON
    async function buyGold(pack) {
      if (!gameState.walletAddress) {
        alert("¬°Conecta tu wallet primero!");
        return;
      }

      try {
        const provider = new ethers.providers.Web3Provider(
          window.ronin?.provider || window.ethereum
        );
        const signer = provider.getSigner();

        // Verificar balance suficiente
        const currentBalance = await provider.getBalance(gameState.walletAddress);
        const requiredBalance = ethers.utils.parseEther(RONIN_SHOP[pack].ron.toString());
        
        if (currentBalance.lt(requiredBalance)) {
          alert("¬°Balance insuficiente para esta compra!");
          return;
        }

        // Mostrar confirmaci√≥n
        const confirmPurchase = confirm(
          `¬øConfirmas la compra de ${RONIN_SHOP[pack].gold} oro por ${RONIN_SHOP[pack].ron} RON?`
        );
        
        if (!confirmPurchase) return;

        // Enviar transacci√≥n
        const tx = await signer.sendTransaction({
          to: HOUSE_WALLET,
          value: requiredBalance
        });

        // Mostrar mensaje de espera
        alert(`Transacci√≥n enviada. Esperando confirmaci√≥n... (TX: ${tx.hash})`);

        // Esperar confirmaci√≥n
        await tx.wait();
        
        // A√±adir oro al juego
        gameState.gold += RONIN_SHOP[pack].gold;
        updateGameDisplay();
        
        alert(`¬°Compra exitosa! +${RONIN_SHOP[pack].gold} oro. TX: ${tx.hash}`);
        
        // Actualizar balance
        await checkRoninBalance();
      } catch (error) {
        console.error("Error en la compra:", error);
        alert("Error al enviar RON: " + (error.message || error));
      }
    }

    // Solicitar retiro de oro a RON
    async function requestWithdraw() {
      const amount = parseInt(document.getElementById('withdrawAmount').value);
      
      if (!amount || isNaN(amount) || amount <= 0) {
        alert("¬°Por favor ingresa una cantidad v√°lida!");
        return;
      }

      if (amount > gameState.gold) {
        alert("¬°No tienes suficiente oro para retirar!");
        return;
      }

      if (!gameState.walletAddress) {
        alert("¬°Conecta tu wallet primero!");
        return;
      }

      try {
        const provider = new ethers.providers.Web3Provider(
          window.ronin?.provider || window.ethereum
        );
        const signer = provider.getSigner();
        
        const message = `Solicito retiro de ${amount} oro a RON`;
        const signature = await signer.signMessage(message);
        
        // Aqu√≠ normalmente enviar√≠as esta informaci√≥n a tu backend
        // Para este ejemplo, simulamos el proceso
        document.getElementById('withdrawStatus').textContent = 
          "Solicitud enviada. Revisi√≥n manual pendiente.";
        document.getElementById('withdrawStatus').style.color = "#4cc9f0";
        
        console.log("Solicitud de retiro:", {
          wallet: gameState.walletAddress,
          amount,
          message,
          signature,
          ronAmount: amount / 1000
        });

        // Restar el oro (en producci√≥n, esperar√≠as confirmaci√≥n del backend)
        gameState.gold -= amount;
        updateGameDisplay();
        
        alert(`Solicitud de retiro enviada. Se convertir√° a ${amount / 1000} RON.`);
      } catch (error) {
        console.error("Error en retiro:", error);
        document.getElementById('withdrawStatus').textContent = "Error: " + (error.message || error);
        document.getElementById('withdrawStatus').style.color = "#ff5555";
      }
    }

    // ================ FUNCIONES DEL JUEGO ================
    function loadGame() {
      const savedGame = localStorage.getItem('bombermanAutoFarmSave');
      if (savedGame) {
        const parsed = JSON.parse(savedGame);
        Object.assign(gameState, parsed);
        updateGameDisplay();
        
        gameState.characters = gameState.characters.map(c => ({
          ...c,
          move: function() { moveCharacter(this); },
          bombsPlaced: c.bombsPlaced || 0,
          totalGoldEarned: c.totalGoldEarned || 0
        }));
        
        gameState.activeCharacters = gameState.characters.filter(c => c.active && c.totalGoldEarned < 1500);
        
        // Restaurar estado del mapa si existe
        if (gameState.mapState) {
          gameState.boxes = gameState.mapState.boxes;
          gameState.breakableWalls = gameState.mapState.breakableWalls;
          gameState.fixedWalls = gameState.mapState.fixedWalls;
        } else if (gameState.mapSeed) {
          generateMap(gameState.mapSeed);
        } else {
          const newSeed = Date.now();
          gameState.mapSeed = newSeed;
          generateMap(newSeed);
        }
      } else {
        // Nueva partida
        const newSeed = Date.now();
        gameState.mapSeed = newSeed;
        generateMap(newSeed);
      }
    }

    function saveGame() {
      // Guardar estado actual del mapa
      gameState.mapState = {
        boxes: [...gameState.boxes],
        breakableWalls: [...gameState.breakableWalls],
        fixedWalls: [...gameState.fixedWalls]
      };
      
      const toSave = {
        ...gameState,
        characters: gameState.characters.map(c => {
          const { move, ...rest } = c;
          return rest;
        }),
        activeCharacters: []
      };
      localStorage.setItem('bombermanAutoFarmSave', JSON.stringify(toSave));
    }

    function updateGameDisplay() {
      goldDisplay.textContent = gameState.gold.toFixed(2);
      levelDisplay.textContent = gameState.level;
      xpDisplay.textContent = `${Math.floor(gameState.xp)}/${gameState.xpToNextLevel}`;
      buyButton.disabled = gameState.gold < 1000;
      spinButton.disabled = gameState.gold < SLOT_CONFIG.cost || gameState.slotMachine.spinning;
    }

    function addXP(amount) {
      gameState.xp += amount;
      
      if (gameState.xp >= gameState.xpToNextLevel) {
        gameState.level++;
        gameState.xp -= gameState.xpToNextLevel;
        gameState.xpToNextLevel = Math.floor(gameState.xpToNextLevel * 1.5);
        
        soundLevelUp.play();
        gameState.levelUpNotifications.push({
          x: Math.floor(MAP_WIDTH / 2) * TILE_SIZE,
          y: Math.floor(MAP_HEIGHT / 2) * TILE_SIZE,
          text: `¬°NIVEL ${gameState.level}!`,
          time: Date.now()
        });
      }
      
      updateGameDisplay();
    }

    function generateMap(seed) {
      // Usamos la semilla para generar un mapa consistente
      const random = new Math.seedrandom(seed);
      
      gameState.boxes = [];
      gameState.breakableWalls = [];
      gameState.fixedWalls = [];
      gameState.powerUps = [];

      // Muros fijos
      for (let y = 0; y < MAP_HEIGHT; y++) {
        for (let x = 0; x < MAP_WIDTH; x++) {
          if (
            x === 0 || y === 0 ||
            y === MAP_HEIGHT - 1 ||
            x === MAP_WIDTH - 1 ||
            (x % 2 === 0 && y % 2 === 0)
          ) {
            gameState.fixedWalls.push({ x, y });
          }
        }
      }

      // Cajas
      const numBoxes = Math.floor(random() * 5) + 4;
      for (let i = 0; i < numBoxes; i++) {
        let pos;
        do {
          pos = {
            x: Math.floor(random() * (MAP_WIDTH - 2)) + 1,
            y: Math.floor(random() * (MAP_HEIGHT - 2)) + 1,
            hasPowerUp: random() < 0.2
          };
        } while (isOccupied(pos.x, pos.y));
        
        gameState.boxes.push({ 
          ...pos, 
          health: 100, 
          maxHealth: 100,
          gold: getRandomGoldDrop()
        });
      }

      // Muros rompibles
      const numBreakable = Math.floor(random() * 15) + 20;
      for (let i = 0; i < numBreakable; i++) {
        let pos;
        do {
          pos = {
            x: Math.floor(random() * (MAP_WIDTH - 2)) + 1,
            y: Math.floor(random() * (MAP_HEIGHT - 2)) + 1
          };
        } while (isOccupied(pos.x, pos.y));
        
        gameState.breakableWalls.push({ 
          ...pos, 
          health: 150, 
          maxHealth: 150 
        });
      }
    }

    function getRandomGoldDrop() {
      let total = 0;
      GOLD_DROPS.forEach(drop => total += drop.chance);
      
      let random = Math.random() * total;
      for (const drop of GOLD_DROPS) {
        if (random < drop.chance) return drop.amount;
        random -= drop.chance;
      }
      return 0.5;
    }

    function isOccupied(x, y) {
      return gameState.fixedWalls.some(w => w.x === x && w.y === y) ||
             gameState.boxes.some(b => b.x === x && b.y === y) ||
             gameState.breakableWalls.some(bw => bw.x === x && bw.y === y);
    }

    buyButton.onclick = () => {
      const basePrice = 1000;
      if (gameState.gold < basePrice) return;
      if (gameState.characters.length >= 10) return;
      
      gameState.gold -= basePrice;
      updateGameDisplay();
      soundBuy.play();

      const rand = Math.random();
      let rarity, acc = 0;
      for (let r of RARITIES) {
        acc += r.chance;
        if (rand <= acc) { 
          rarity = r; 
          break; 
        }
      }

      const characterId = Date.now();
      const character = {
        id: characterId,
        x: 1,
        y: 1,
        energy: rarity.baseEnergy,
        maxEnergy: rarity.baseEnergy,
        damage: rarity.baseDamage,
        speed: rarity.baseSpeed,
        rarity: rarity.name,
        rarityClass: rarity.class,
        color: rarity.color,
        active: false,
        level: 1,
        xp: 0,
        xpToNextLevel: 100,
        moveProgress: 0,
        path: [],
        move: function() { moveCharacter(this); },
        roiDays: rarity.roiDays,
        bombsPlaced: 0,
        totalGoldEarned: 0,
        bombCost: rarity.bombCost,
        symbol: rarity.symbol
      };
      
      gameState.characters.push(character);
      updateInventory();
      
      buyButton.textContent = "¬°PERSONAJE OBTENIDO!";
      buyButton.style.background = "linear-gradient(135deg, #2ecc71, #27ae60)";
      setTimeout(() => {
        buyButton.textContent = `COMPRAR PERSONAJE (${basePrice} ORO)`;
        buyButton.style.background = "linear-gradient(135deg, var(--accent), #ff7b25)";
      }, 1000);
      
      saveGame();
    };

    function updateInventory() {
      activeCharactersDiv.innerHTML = "";
      inactiveCharactersDiv.innerHTML = "";
      
      if (gameState.characters.length === 0) {
        activeCharactersDiv.innerHTML = `<p style="text-align: center; color: #777;">No tienes personajes activos</p>`;
        inactiveCharactersDiv.innerHTML = `<p style="text-align: center; color: #777;">No tienes personajes inactivos</p>`;
        return;
      }
      
      // Personajes activos
      const activeCharacters = gameState.characters.filter(c => c.active && c.totalGoldEarned < 1500);
      if (activeCharacters.length === 0) {
        activeCharactersDiv.innerHTML = `<p style="text-align: center; color: #777;">No tienes personajes activos</p>`;
      } else {
        activeCharacters.forEach(c => {
          const rechargeCost = RECHARGE_COSTS[c.rarityClass.toLowerCase()];
          
          const el = document.createElement("div");
          el.className = `character-card ${c.rarityClass}`;
          el.innerHTML = `
            <div class="character-name">
              <span>${c.rarity}</span>
              <span class="character-level">Nvl ${c.level}</span>
            </div>
            <div>Da√±o: ${c.damage.toFixed(1)}</div>
            <div>Velocidad: ${(c.speed * 100).toFixed(1)}%</div>
            <div>ROI: ${c.roiDays} d√≠as</div>
            <div>Energ√≠a: ${Math.floor(c.energy)}/${c.maxEnergy}</div>
            <div class="bar-container">
              <div class="bar energy-bar" style="width:${(c.energy/c.maxEnergy)*100}%"></div>
            </div>
            <div>XP: ${Math.floor(c.xp)}/${c.xpToNextLevel}</div>
            <div class="bar-container">
              <div class="bar xp-bar" style="width:${(c.xp/c.xpToNextLevel)*100}%"></div>
            </div>
            <div>Oro generado: ${c.totalGoldEarned.toFixed(2)}/1500</div>
            <div class="bar-container">
              <div class="bar" style="width:${(c.totalGoldEarned/1500)*100}%; background: linear-gradient(90deg, #ffd700, #ff9900)"></div>
            </div>
            <button class="active">DESACTIVAR</button>
            <button class="recharge-button" data-cost="${rechargeCost}">RECARGAR (${rechargeCost} ORO)</button>`;
          
          const btn = el.querySelector("button:not(.recharge-button)");
          btn.onclick = () => {
            c.active = false;
            gameState.activeCharacters = gameState.activeCharacters.filter(a => a.id !== c.id);
            updateInventory();
            saveGame();
          };
          
          const rechargeBtn = el.querySelector(".recharge-button");
          rechargeBtn.onclick = () => {
            const cost = parseFloat(rechargeBtn.getAttribute("data-cost"));
            
            if (gameState.gold >= cost && c.energy < c.maxEnergy) {
              gameState.gold -= cost;
              c.energy = c.maxEnergy;
              
              soundRecharge.play();
              rechargeBtn.textContent = "¬°RECARGADO!";
              rechargeBtn.style.background = "linear-gradient(135deg, #2ecc71, #27ae60)";
              
              setTimeout(() => {
                rechargeBtn.textContent = `RECARGAR (${cost} ORO)`;
                rechargeBtn.style.background = "linear-gradient(135deg, #4cc9f0, #4895ef)";
              }, 1000);
              
              updateGameDisplay();
              updateInventory();
              saveGame();
            } else if (gameState.gold < cost) {
              rechargeBtn.textContent = "¬°NO HAY ORO!";
              rechargeBtn.style.background = "#f72585";
              
              setTimeout(() => {
                rechargeBtn.textContent = `RECARGAR (${cost} ORO)`;
                rechargeBtn.style.background = "linear-gradient(135deg, #4cc9f0, #4895ef)";
              }, 1000);
            }
          };
          
          if (c.energy <= 0) {
            btn.disabled = true;
            btn.textContent = "SIN ENERG√çA";
          }
          
          if (c.energy >= c.maxEnergy) {
            rechargeBtn.disabled = true;
            rechargeBtn.textContent = "ENERG√çA LLENA";
          } else if (gameState.gold < rechargeCost) {
            rechargeBtn.disabled = true;
          }
          
          activeCharactersDiv.appendChild(el);
        });
      }
      
      // Personajes inactivos
      const inactiveCharacters = gameState.characters.filter(c => !c.active || c.totalGoldEarned >= 1500);
      if (inactiveCharacters.length === 0) {
        inactiveCharactersDiv.innerHTML = `<p style="text-align: center; color: #777;">No tienes personajes inactivos</p>`;
      } else {
        inactiveCharacters.forEach(c => {
          const rechargeCost = RECHARGE_COSTS[c.rarityClass.toLowerCase()];
          const isDead = c.totalGoldEarned >= 1500;
          
          const el = document.createElement("div");
          el.className = `character-card ${c.rarityClass} ${isDead ? 'dead-character' : ''}`;
          el.innerHTML = `
            <div class="character-name">
              <span>${c.rarity}</span>
              <span class="character-level">Nvl ${c.level}</span>
            </div>
            <div>Da√±o: ${c.damage.toFixed(1)}</div>
            <div>Velocidad: ${(c.speed * 100).toFixed(1)}%</div>
            <div>ROI: ${c.roiDays} d√≠as</div>
            <div>Energ√≠a: ${Math.floor(c.energy)}/${c.maxEnergy}</div>
            <div class="bar-container">
              <div class="bar energy-bar" style="width:${(c.energy/c.maxEnergy)*100}%"></div>
            </div>
            <div>XP: ${Math.floor(c.xp)}/${c.xpToNextLevel}</div>
            <div class="bar-container">
              <div class="bar xp-bar" style="width:${(c.xp/c.xpToNextLevel)*100}%"></div>
            </div>
            <div>Oro generado: ${c.totalGoldEarned.toFixed(2)}/1500</div>
            <div class="bar-container">
              <div class="bar" style="width:${(c.totalGoldEarned/1500)*100}%; background: linear-gradient(90deg, #ffd700, #ff9900)"></div>
            </div>
            ${isDead ? 
              '<button class="revive-button">REVIVIR (500 ORO)</button>' : 
              `<button>ACTIVAR</button>
               <button class="recharge-button" data-cost="${rechargeCost}">RECARGAR (${rechargeCost} ORO)</button>`}`;
          
          if (!isDead) {
            const btn = el.querySelector("button:not(.recharge-button)");
            btn.onclick = () => {
              if (c.energy > 0) {
                c.active = true;
                gameState.activeCharacters.push(c);
                updateInventory();
                saveGame();
              }
            };
            
            const rechargeBtn = el.querySelector(".recharge-button");
            rechargeBtn.onclick = () => {
              const cost = parseFloat(rechargeBtn.getAttribute("data-cost"));
              
              if (gameState.gold >= cost && c.energy < c.maxEnergy) {
                gameState.gold -= cost;
                c.energy = c.maxEnergy;
                
                soundRecharge.play();
                rechargeBtn.textContent = "¬°RECARGADO!";
                rechargeBtn.style.background = "linear-gradient(135deg, #2ecc71, #27ae60)";
                
                setTimeout(() => {
                  rechargeBtn.textContent = `RECARGAR (${cost} ORO)`;
                  rechargeBtn.style.background = "linear-gradient(135deg, #4cc9f0, #4895ef)";
                }, 1000);
                
                updateGameDisplay();
                updateInventory();
                saveGame();
              } else if (gameState.gold < cost) {
                rechargeBtn.textContent = "¬°NO HAY ORO!";
                rechargeBtn.style.background = "#f72585";
                
                setTimeout(() => {
                  rechargeBtn.textContent = `RECARGAR (${cost} ORO)`;
                  rechargeBtn.style.background = "linear-gradient(135deg, #4cc9f0, #4895ef)";
                }, 1000);
              }
            };
            
            if (c.energy <= 0) {
              btn.disabled = true;
              btn.textContent = "SIN ENERG√çA";
            }
            
            if (c.energy >= c.maxEnergy) {
              rechargeBtn.disabled = true;
              rechargeBtn.textContent = "ENERG√çA LLENA";
            } else if (gameState.gold < rechargeCost) {
              rechargeBtn.disabled = true;
            }
          } else {
            const reviveBtn = el.querySelector(".revive-button");
            reviveBtn.onclick = () => {
              if (gameState.gold >= 500) {
                gameState.gold -= 500;
                c.totalGoldEarned = 0;
                c.energy = c.maxEnergy;
                soundRevive.play();
                updateGameDisplay();
                updateInventory();
                saveGame();
              } else {
                reviveBtn.textContent = "¬°NO HAY ORO!";
                reviveBtn.style.background = "#f72585";
                
                setTimeout(() => {
                  reviveBtn.textContent = `REVIVIR (500 ORO)`;
                  reviveBtn.style.background = "linear-gradient(135deg, #f72585, #b5179e)";
                }, 1000);
              }
            };
          }
          
          inactiveCharactersDiv.appendChild(el);
        });
      }
    }

    function isBlocked(x, y) {
      return gameState.fixedWalls.some(w => w.x === x && w.y === y) ||
             gameState.boxes.some(b => b.x === x && b.y === y) ||
             gameState.breakableWalls.some(bw => bw.x === x && bw.y === y) ||
             gameState.bombs.some(b => b.x === x && b.y === y);
    }

    function placeBomb(character) {
      if (gameState.bombs.some(b => b.x === character.x && b.y === character.y)) return;
      
      character.bombsPlaced++;
      character.energy -= character.bombCost;
      if (character.energy < 0) character.energy = 0;
      
      gameState.bombs.push({ 
        x: character.x, 
        y: character.y, 
        damage: character.damage * 50, 
        timer: Date.now() + 1000,
        radius: 2 + Math.floor(character.level / 5),
        ownerId: character.id
      });

      if (character.energy <= 0) {
        character.active = false;
        gameState.activeCharacters = gameState.activeCharacters.filter(a => a.id !== character.id);
        updateInventory();
      }
      
      saveGame();
    }

    function moveCharacter(character) {
      const targets = [...gameState.boxes, ...gameState.breakableWalls];
      if (!targets.length) return;

      if (!character.path.length) {
        const allTargets = [...targets];
        shuffleArray(allTargets);
        
        for (const target of allTargets) {
          const directions = [
            {dx: 1, dy: 0}, {dx: -1, dy: 0},
            {dx: 0, dy: 1}, {dx: 0, dy: -1}
          ];
          
          for (const dir of directions) {
            const ax = target.x + dir.dx;
            const ay = target.y + dir.dy;
            
            if (
              ax >= 0 && ax < MAP_WIDTH &&
              ay >= 0 && ay < MAP_HEIGHT &&
              !isBlocked(ax, ay)
            ) {
              character.path = findPath(character.x, character.y, ax, ay);
              if (character.path.length) break;
            }
          }
          if (character.path.length) break;
        }
      }

      if (character.path.length) {
        const next = character.path[0];
        character.moveProgress += character.speed;
        
        if (character.moveProgress >= 1) {
          character.x = next.x;
          character.y = next.y;
          character.path.shift();
          character.moveProgress = 0;
        }
      }

      if (checkAdjacentTargets(character.x, character.y)) {
        placeBomb(character);
      }
    }

    function checkAdjacentTargets(x, y) {
      const dirs = [
        {dx: 1, dy: 0}, {dx: -1, dy: 0},
        {dx: 0, dy: 1}, {dx: 0, dy: -1}
      ];
      
      return dirs.some(dir => {
        const nx = x + dir.dx, ny = y + dir.dy;
        return nx >= 0 && nx < MAP_WIDTH &&
               ny >= 0 && ny < MAP_HEIGHT &&
               (gameState.boxes.some(b => b.x === nx && b.y === ny) ||
                gameState.breakableWalls.some(w => w.x === nx && w.y === ny));
      });
    }

    function findPath(sx, sy, tx, ty) {
      const dirs = [
        {dx: 1, dy: 0}, {dx: -1, dy: 0},
        {dx: 0, dy: 1}, {dx: 0, dy: -1}
      ];
      
      const visited = Array(MAP_HEIGHT).fill().map(() => Array(MAP_WIDTH).fill(false));
      const queue = [{ x: sx, y: sy, path: [] }];
      visited[sy][sx] = true;

      while (queue.length) {
        const cur = queue.shift();
        if (cur.x === tx && cur.y === ty) return cur.path;
        
        for (const d of dirs) {
          const nx = cur.x + d.dx, ny = cur.y + d.dy;
          
          if (
            nx >= 0 && nx < MAP_WIDTH &&
            ny >= 0 && ny < MAP_HEIGHT &&
            !visited[ny][nx] &&
            !isBlocked(nx, ny)
          ) {
            visited[ny][nx] = true;
            queue.push({ 
              x: nx, 
              y: ny, 
              path: [...cur.path, {x: nx, y: ny}] 
            });
          }
        }
      }
      return [];
    }

    function drawChest(x, y, healthRatio) {
      ctx.fillStyle = "#8B4513";
      ctx.fillRect(x * TILE_SIZE + 5, y * TILE_SIZE + 10, TILE_SIZE - 10, TILE_SIZE - 15);
      
      ctx.fillStyle = "#A0522D";
      ctx.beginPath();
      ctx.moveTo(x * TILE_SIZE + 5, y * TILE_SIZE + 10);
      ctx.lineTo(x * TILE_SIZE + TILE_SIZE / 2, y * TILE_SIZE + 5);
      ctx.lineTo(x * TILE_SIZE + TILE_SIZE - 5, y * TILE_SIZE + 10);
      ctx.closePath();
      ctx.fill();
      
      ctx.fillStyle = "#FFD700";
      ctx.beginPath();
      ctx.arc(
        x * TILE_SIZE + TILE_SIZE / 2,
        y * TILE_SIZE + TILE_SIZE / 2,
        4,
        0,
        Math.PI * 2
      );
      ctx.fill();
      
      drawHealthBar(x, y, healthRatio, "#55ff55");
    }

    function drawHealthBar(x, y, ratio, color) {
      const barHeight = 4;
      const barWidth = TILE_SIZE - 4;
      
      ctx.fillStyle = "rgba(0, 0, 0, 0.5)";
      ctx.fillRect(
        x * TILE_SIZE + 2,
        y * TILE_SIZE - 8,
        barWidth,
        barHeight
      );
      
      ctx.fillStyle = color;
      ctx.fillRect(
        x * TILE_SIZE + 2,
        y * TILE_SIZE - 8,
        barWidth * Math.max(0, Math.min(1, ratio)),
        barHeight
      );
    }

    function shuffleArray(array) {
      for (let i = array.length - 1; i > 0; i--) {
        const j = Math.floor(Math.random() * (i + 1));
        [array[i], array[j]] = [array[j], array[i]];
      }
    }

    function generatePowerUp(x, y) {
      const powerUpType = weightedRandom(POWER_UPS);
      gameState.powerUps.push({
        x,
        y,
        type: powerUpType.type,
        color: powerUpType.color,
        effect: powerUpType.effect
      });
    }

    function weightedRandom(items) {
      let total = items.reduce((sum, item) => sum + item.chance, 0);
      let random = Math.random() * total;
      
      for (const item of items) {
        if (random < item.chance) return item;
        random -= item.chance;
      }
      
      return items[0];
    }

    function applyPowerUp(powerUp, character) {
      powerUp.effect(character);
      soundPowerUp.play();
      
      gameState.goldNotifications.push({
        x: character.x * TILE_SIZE + TILE_SIZE / 2,
        y: character.y * TILE_SIZE,
        text: `POWER UP! ${powerUp.type.toUpperCase()}`,
        time: Date.now(),
        color: powerUp.color
      });
      
      character.xp += 5;
      if (character.xp >= character.xpToNextLevel) {
        character.level++;
        character.xp -= character.xpToNextLevel;
        character.xpToNextLevel = Math.floor(character.xpToNextLevel * 1.5);
        
        character.damage *= 1.1;
        character.speed *= 1.05;
        character.maxEnergy = Math.floor(character.maxEnergy * 1.1);
        character.energy = character.maxEnergy;
        
        gameState.levelUpNotifications.push({
          x: character.x * TILE_SIZE + TILE_SIZE / 2,
          y: character.y * TILE_SIZE,
          text: `¬°NVL ${character.level}!`,
          time: Date.now()
        });
      }
      
      updateInventory();
      saveGame();
    }

    function gameLoop() {
      ctx.clearRect(0, 0, canvas.width, canvas.height);
      const now = Date.now();

      // Dibujar fondo del mapa
      for (let y = 0; y < MAP_HEIGHT; y++) {
        for (let x = 0; x < MAP_WIDTH; x++) {
          ctx.fillStyle = (x + y) % 2 === 0 ? "#2a2a40" : "#252535";
          ctx.fillRect(x * TILE_SIZE, y * TILE_SIZE, TILE_SIZE, TILE_SIZE);
        }
      }

      // Dibujar muros fijos
      gameState.fixedWalls.forEach(w => {
        ctx.fillStyle = "#3a3a5a";
        ctx.fillRect(w.x * TILE_SIZE, w.y * TILE_SIZE, TILE_SIZE, TILE_SIZE);
        
        ctx.fillStyle = "#4a4a7a";
        ctx.fillRect(w.x * TILE_SIZE, w.y * TILE_SIZE, TILE_SIZE, 3);
        ctx.fillRect(w.x * TILE_SIZE, w.y * TILE_SIZE, 3, TILE_SIZE);
      });

      // Dibujar muros rompibles
      gameState.breakableWalls.forEach(b => {
        ctx.fillStyle = "#5a3a3a";
        ctx.fillRect(b.x * TILE_SIZE, b.y * TILE_SIZE, TILE_SIZE, TILE_SIZE);
        
        ctx.fillStyle = "#6a4a4a";
        for (let i = 0; i < 3; i++) {
          for (let j = 0; j < 2; j++) {
            if (Math.random() > 0.3) {
              ctx.fillRect(
                b.x * TILE_SIZE + 5 + i * 8,
                b.y * TILE_SIZE + 5 + j * 12,
                6, 4
              );
            }
          }
        }
        
        drawHealthBar(b.x, b.y, b.health / b.maxHealth, "#ff5555");
      });

      // Dibujar cofres
      gameState.boxes.forEach(b => {
        drawChest(b.x, b.y, b.health / b.maxHealth);
      });

      // Dibujar power-ups
      gameState.powerUps.forEach(pu => {
        ctx.fillStyle = pu.color;
        ctx.beginPath();
        ctx.arc(
          pu.x * TILE_SIZE + TILE_SIZE / 2,
          pu.y * TILE_SIZE + TILE_SIZE / 2,
          TILE_SIZE / 3,
          0,
          Math.PI * 2
        );
        ctx.fill();
        
        ctx.fillStyle = "rgba(255, 255, 255, 0.3)";
        ctx.beginPath();
        ctx.arc(
          pu.x * TILE_SIZE + TILE_SIZE / 2 + 5,
          pu.y * TILE_SIZE + TILE_SIZE / 2 - 5,
          TILE_SIZE / 6,
          0,
          Math.PI * 2
        );
        ctx.fill();
      });

      // Dibujar bombas y explosiones
      gameState.bombs = gameState.bombs.filter(b => {
        if (now >= b.timer) {
          soundExplosion.currentTime = 0;
          soundExplosion.play();
          
          ctx.fillStyle = `rgba(255, 165, 0, 0.5)`;
          ctx.beginPath();
          ctx.arc(
            b.x * TILE_SIZE + TILE_SIZE / 2,
            b.y * TILE_SIZE + TILE_SIZE / 2,
            b.radius * TILE_SIZE,
            0,
            Math.PI * 2
          );
          ctx.fill();
          
          for (let i = -b.radius; i <= b.radius; i++) {
            for (let j = -b.radius; j <= b.radius; j++) {
              if (Math.abs(i) + Math.abs(j) <= b.radius) {
                const tx = b.x + i, ty = b.y + j;
                
                gameState.boxes.forEach((box, index) => {
                  if (box.x === tx && box.y === ty) {
                    box.health -= b.damage;
                    
                    if (box.health <= 0) {
                      const owner = gameState.characters.find(c => c.id === b.ownerId);
                      if (owner) {
                        let goldMultiplier = 1.0;
                        goldMultiplier = owner.damage * (1 + owner.level / 10);
                        
                        const goldEarned = box.gold * goldMultiplier * (1 + gameState.level / 20);
                        gameState.gold += goldEarned;
                        owner.totalGoldEarned += goldEarned;
                        addXP(goldEarned);
                        
                        showGoldNotification(box.x, box.y, goldEarned);
                        
                        if (box.hasPowerUp) {
                          generatePowerUp(box.x, box.y);
                        }
                        
                        owner.xp += 10;
                        if (owner.xp >= owner.xpToNextLevel) {
                          owner.level++;
                          owner.xp -= owner.xpToNextLevel;
                          owner.xpToNextLevel = Math.floor(owner.xpToNextLevel * 1.5);
                          
                          owner.damage *= 1.1;
                          owner.speed *= 1.05;
                          owner.maxEnergy = Math.floor(owner.maxEnergy * 1.1);
                          owner.energy = owner.maxEnergy;
                          
                          gameState.levelUpNotifications.push({
                            x: owner.x * TILE_SIZE + TILE_SIZE / 2,
                            y: owner.y * TILE_SIZE,
                            text: `¬°NVL ${owner.level}!`,
                            time: now
                          });
                        }

                        // Verificar si el personaje alcanz√≥ el ROI m√°ximo
                        if (owner.totalGoldEarned >= 1500) {
                          owner.active = false;
                          gameState.activeCharacters = gameState.activeCharacters.filter(c => c.id !== owner.id);
                        }
                      }
                    }
                  }
                });
                
                gameState.breakableWalls.forEach(w => {
                  if (w.x === tx && w.y === ty) {
                    w.health -= b.damage;
                  }
                });
              }
            }
          }
          
          updateGameDisplay();
          updateInventory();
          return false;
        }
        
        ctx.fillStyle = "#444";
        ctx.beginPath();
        ctx.arc(
          b.x * TILE_SIZE + TILE_SIZE / 2,
          b.y * TILE_SIZE + TILE_SIZE / 2,
          TILE_SIZE / 3,
          0,
          Math.PI * 2
        );
        ctx.fill();
        
        const fuseProgress = (b.timer - now) / 1000;
        ctx.fillStyle = fuseProgress < 0.3 ? "#f00" : "#ff5e00";
        ctx.beginPath();
        ctx.moveTo(b.x * TILE_SIZE + TILE_SIZE / 2, b.y * TILE_SIZE + 5);
        ctx.lineTo(b.x * TILE_SIZE + TILE_SIZE / 2 - 5, b.y * TILE_SIZE);
        ctx.lineTo(b.x * TILE_SIZE + TILE_SIZE / 2 + 5, b.y * TILE_SIZE);
        ctx.closePath();
        ctx.fill();
        
        return true;
      });

      // Dibujar notificaciones de oro
      gameState.goldNotifications = gameState.goldNotifications.filter(n => {
        const elapsed = now - n.time;
        if (elapsed > 1000) return false;
        
        ctx.save();
        ctx.font = "bold 14px 'Press Start 2P', cursive";
        ctx.fillStyle = n.color || `rgba(255, 215, 0, ${1 - elapsed / 1000})`;
        ctx.textAlign = "center";
        ctx.fillText(n.text, n.x, n.y - (elapsed / 20));
        ctx.restore();
        
        return true;
      });

      // Dibujar notificaciones de nivel
      gameState.levelUpNotifications = gameState.levelUpNotifications.filter(n => {
        const elapsed = now - n.time;
        if (elapsed > 1000) return false;
        
        ctx.save();
        ctx.font = "bold 16px 'Press Start 2P', cursive";
        ctx.fillStyle = `rgba(76, 201, 240, ${1 - elapsed / 1000})`;
        ctx.textAlign = "center";
        ctx.fillText(n.text, n.x, n.y - (elapsed / 15));
        ctx.restore();
        
        return true;
      });

      // Dibujar personajes
      gameState.activeCharacters.forEach(c => {
        ctx.fillStyle = c.color;
        ctx.beginPath();
        ctx.arc(
          c.x * TILE_SIZE + TILE_SIZE / 2,
          c.y * TILE_SIZE + TILE_SIZE / 2,
          TILE_SIZE / 2 - 4,
          0,
          Math.PI * 2
        );
        ctx.fill();
        
        const eyeX = c.path.length ? 
          (c.path[0].x > c.x ? 5 : -5) : 0;
        
        ctx.fillStyle = "#fff";
        ctx.beginPath();
        ctx.arc(
          c.x * TILE_SIZE + TILE_SIZE / 2 - 5 + eyeX/2,
          c.y * TILE_SIZE + TILE_SIZE / 2 - 3,
          3,
          0,
          Math.PI * 2
        );
        ctx.arc(
          c.x * TILE_SIZE + TILE_SIZE / 2 + 5 + eyeX/2,
          c.y * TILE_SIZE + TILE_SIZE / 2 - 3,
          3,
          0,
          Math.PI * 2
        );
        ctx.fill();
        
        drawHealthBar(c.x, c.y, c.energy / c.maxEnergy, "#00ff00");
        c.move();
        
        gameState.powerUps = gameState.powerUps.filter(pu => {
          if (pu.x === c.x && pu.y === c.y) {
            applyPowerUp(pu, c);
            return false;
          }
          return true;
        });
      });

      gameState.boxes = gameState.boxes.filter(b => b.health > 0);
      gameState.breakableWalls = gameState.breakableWalls.filter(b => b.health > 0);
      
      if (!gameState.boxes.length && !gameState.breakableWalls.length) {
        // Generar nuevo mapa con nueva semilla cuando se destruye todo
        const newSeed = Date.now();
        gameState.mapSeed = newSeed;
        generateMap(newSeed);
      }

      requestAnimationFrame(gameLoop);
    }

    function findClosestCharacter(x, y) {
      if (gameState.activeCharacters.length === 0) return null;
      
      let closest = gameState.activeCharacters[0];
      let minDist = distance(x, y, closest.x, closest.y);
      
      for (const char of gameState.activeCharacters) {
        const dist = distance(x, y, char.x, char.y);
        if (dist < minDist) {
          minDist = dist;
          closest = char;
        }
      }
      
      return closest;
    }

    function distance(x1, y1, x2, y2) {
      return Math.sqrt(Math.pow(x2 - x1, 2) + Math.pow(y2 - y1, 2));
    }

    function showGoldNotification(x, y, amount) {
      soundGold.currentTime = 0;
      soundGold.play();
      
      gameState.goldNotifications.push({
        x: x * TILE_SIZE + TILE_SIZE / 2,
        y: y * TILE_SIZE,
        text: `+${amount.toFixed(2)}`,
        time: Date.now()
      });
    }

    // ================ INICIALIZACI√ìN ================
    // Polyfill para seedrandom si no est√° disponible
    if (typeof Math.seedrandom !== 'function') {
      Math.seedrandom = function(seed) {
        // Implementaci√≥n simple de seedrandom
        let value = seed;
        return function() {
          value = (value * 9301 + 49297) % 233280;
          return value / 233280;
        };
      };
    }

    loadGame();
    updateInventory();
    updateJackpotDisplay();
    gameLoop();

    // Event listeners
    connectRoninBtn.addEventListener('click', connectRonin);
    spinButton.addEventListener('click', spinSlot);
    
    document.querySelectorAll('.pack').forEach(pack => {
      pack.addEventListener('click', () => {
        const packType = pack.getAttribute('data-pack');
        buyGold(packType);
      });
    });

    document.querySelectorAll('.tab-button').forEach(button => {
      button.addEventListener('click', () => {
        document.querySelectorAll('.tab-button').forEach(btn => btn.classList.remove('active'));
        document.querySelectorAll('.tab-content').forEach(content => content.classList.remove('active'));
        
        button.classList.add('active');
        const tabId = button.getAttribute('data-tab') + '-tab';
        document.getElementById(tabId).classList.add('active');
      });
    });

    // Verificar autom√°ticamente si Ronin est√° instalado al cargar la p√°gina
    window.addEventListener('load', () => {
      if (isRoninInstalled()) {
        connectRoninBtn.textContent = "Ronin Wallet Detectada";
        connectRoninBtn.style.background = "linear-gradient(135deg, #2ecc71, #27ae60)";
      }
    });

    // Guardar autom√°ticamente cada 30 segundos
    setInterval(saveGame, 30000);
  </script>
</body>
</html>
